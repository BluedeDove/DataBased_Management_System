"11.3 图书管理系统 11.3.1 背景简介 随着科学技术的不断提高，计算机科学日渐成熟，它已进入人类社会的各个领域并发挥 着越来越重要的作用，作为计算机应用的一部分，使用计算机对图书信息进行管理，具有手 工管理所无法比拟的优点，如检索迅速、查找方便、易修改、可靠性高、存储量大、数据处 理快捷、便于打印等，因此图书管理系统是图书馆管理工作中不可缺少的部分，可以为管理 者或读者提供充足的信息和快捷的数据处理手段。 11.3.2 系统目标 图书管理信息系统实现的总目标，是使图书馆的信息管理工作系统化、规范化、自动化， 从而达到提高企业人事管理效率的目的。要求实现如下目标： （1）数据输入部分 包括图书基本信息的录入、借阅人基本信息的录入、用户基本信息 的录入。 （2）数据输出部分 主要是各种统计查询，如：根据图书信息（如书名、作者、出版社 等）查阅图书及其借阅信息、统计输出图书类型比例等。 5 （3）数据处理部分 主要包括借阅和归还的处理，如一本书借出后，必须在数据库中将 该书标记为已借出，以防出现数据库中有书但图书馆无书的情况。一本书归还后，同样必须 在数据库中将其标记为已经归还，以便再次借出。 11.3.3 功能要求 根据以上实现目标，图书管理系统的主要功能包括： （1）读者种类的定义、更新、查询 主要实现读者种类标准的制定，如：种类编号、种 类名称、借书数量、借书期限、有效期限、备注等。 （2）读者基本信息的输入、查询、更新 包括读者编号、读者姓名、读者种类、读者性 别、工作单位、家庭住址、电话号码、电子邮件地址、登记日期、备注等。 （3）书籍类别的定义、更新、查询 主要实现书籍类别标准的制定，如：类别编号、类 别名称、关键词、备注信息等。 （4）书籍信息的输入、查询、更新 包括书籍编号、书籍名称、书籍类别、作者姓名、 出版社名称、出版日期、价格、书籍页码、关键词、登记日期、是否被借出、备注信息等。 （5）旧书销毁 对于淘汰、损坏、丢失的书目可及时对数据库进行修改。 （6）借还书信息的输入、查询、更新 包括借阅编号、读者编号、书籍编号、出借日期、 还书日期、备注信息等。 （7）方便、灵活的查询 如：以书名、作者、出版社、出版时间（确定的时间或时间段、 某一时间之前、某一时间之后）等信息进行图书检索，并能反映出图书的借阅情况，以借阅 人编号对借阅人信息进行检索，以出版社名称查询出版社联系方式信息等。 （8）统计分析功能 可以展现出图书类型比例、库存与借出比例等统计信息。"
以上是基础要求 以下是我的构思 请你实现并完善

```
electron-smart-library/
├── release/
├── tests/                         # 👈 新增: 自动化测试目录
│   ├── services/
│   │   └── borrowing.service.spec.ts # 例如: 借阅服务的单元测试
│   └── e2e/
│       └── main.spec.ts           # 端到端测试
├── src/
│   ├── main/
│   │   ├── config/                # 👈 新增: 统一配置管理
│   │   │   └── index.ts
│   │   ├── domains/               # 👈 核心: 按业务领域划分模块
│   │   │   ├── auth/              # 认证与权限
│   │   │   │   ├── auth.service.ts
│   │   │   │   └── user.repository.ts
│   │   │   ├── book/              # 图书领域
│   │   │   │   ├── book.service.ts
│   │   │   │   └── book.repository.ts
│   │   │   ├── borrowing/         # 借阅领域
│   │   │   │   ├── borrowing.service.ts
│   │   │   │   └── borrowing.repository.ts
│   │   │   └── ai/                # AI领域
│   │   │       ├── ai.service.ts
│   │   │       └── vector.repository.ts
│   │   ├── lib/
│   │   │   ├── ipcHandlers.ts     # 控制层: 接收IPC请求, 调用Service
│   │   │   ├── errorHandler.ts    # 👈 新增: 全局错误处理
│   │   │   └── logger.ts          # 👈 新增: 日志服务 (使用winston或electron-log)
│   │   ├── database/
│   │   │   └── index.ts           # 数据库初始化
│   │   └── index.ts               # 主入口
│   │
│   ├── preload/
│   │   └── index.ts
│   │
│   └── renderer/                  # (前端结构基本不变, 但逻辑更清晰)
│       ├── src/
│       │   ├── api/               # 👈 新增: 封装所有 window.api 调用
│       │   │   ├── book.ts
│       │   │   └── borrowing.ts
│       │   ├── services/          # 👈 新增: 前端也可以有服务层 (处理复杂状态逻辑)
│       │   ├── store/             # Pinia 状态管理
│       │   ├── views/             # 页面
│       │   └── ...
│
├── .github/                       # 👈 新增: CI/CD 工作流
│   └── workflows/
│       └── main.yml
├── .env
├── package.json
└── ...
```

当然。这很棒，让我们将这份“企业级”文件结构扩展成一份详尽的、可作为开发蓝图的项目大纲。

这份大纲不仅定义了每个文件的用途，更阐述了它们之间的**协作方式**和**设计哲学**。

---

### **项目名称: `electron-smart-library` - 企业级项目大纲**

#### **核心设计理念**

本项目遵循**领域驱动设计 (DDD)** 和**分层架构**思想，旨在实现**高内聚、低耦合**的终极目标。数据流严格遵循 `视图(View) -> 控制器(Handler) -> 服务(Service) -> 仓库(Repository)` 的单向流动，确保了业务逻辑的清晰、可测试和可维护性。

---

### **Part 1: 主进程 (Main Process) - 应用的后端与大脑**

这是应用的绝对核心，所有业务逻辑、数据库交互和原生操作系统功能都在这里实现。

#### **`src/main/domains/` - 业务领域核心**

这是项目的心脏。我们将复杂的系统按业务能力拆分成独立的、高内聚的“领域”模块。

*   **`domains/borrowing/` (借阅领域 - 示例)**
    *   **`borrowing.service.ts`**
        *   **职责**: **编排和执行借阅相关的复杂业务逻辑**。它是业务规则的最终裁决者。
        *   **实现要点**:
            *   包含 `borrowBook()`, `returnBook()`, `renewBook()` 等方法。
            *   一个方法会调用**多个** Repository。例如 `borrowBook(readerId, bookId)` 的内部流程：
                1.  调用 `bookRepository.findById(bookId)` 确认书籍存在。
                2.  调用 `inventoryRepository.getAvailableCount(bookId)` 检查库存。
                3.  调用 `readerRepository.getBorrowingCount(readerId)` 检查读者借阅是否已达上限。
                4.  如果所有规则通过，则调用 `borrowingRepository.createRecord(...)` 创建借阅记录，并调用 `inventoryRepository.decreaseStock(...)` 减少库存。
            *   **只处理业务，不拼接SQL，不直接响应前端**。
            *   在业务规则不满足时，会抛出自定义的业务异常，例如 `throw new StockUnavailableError('库存不足')`。

    *   **`borrowing.repository.ts`**
        *   **职责**: **作为借阅数据表的唯一接口**。它负责将业务对象（如一个借阅记录）与数据库记录进行相互转换。
        *   **实现要点**:
            *   包含 `createRecord()`, `findActiveRecordByUserAndBook()`, `updateRecord()` 等方法。
            *   **内部只包含纯粹的数据库操作**（如 `db.run('INSERT INTO ...')`, `db.get('SELECT ...')`）。
            *   **完全不懂业务逻辑**。它不知道“借阅上限”是什么，只知道忠实地执行数据读写任务。

*   **`domains/book/`, `domains/auth/`, `domains/ai/`**
    *   结构与 `borrowing` 领域类似，各自包含自己的 `service` 和 `repository`，分别处理图书管理、用户认证/权限、AI问答/向量搜索的业务和数据。

#### **`src/main/lib/` - 通用库与基础设施**

这些模块为所有领域提供支持，处理非业务核心的通用问题。

*   **`ipcHandlers.ts` (控制器层)**
    *   **职责**: **作为渲染进程所有请求的唯一入口**。它像一个交通警察，负责解析请求、调用相应的服务，并返回格式化的响应。
    *   **实现要点**:
        *   注册所有的 `ipcMain.handle('channel', callback)`。
        *   回调函数内部结构非常固定：
            ```typescript
            ipcMain.handle('borrow-book', async (event, readerId, bookId) => {
              try {
                // 1. (可选) 基础参数验证
                // 2. 调用Service层完成业务
                const result = await borrowingService.borrowBook(readerId, bookId);
                // 3. 封装成功的响应
                return { success: true, data: result };
              } catch (error) {
                // 4. 捕获所有异常, 交给错误处理器
                return errorHandler.handle(error); 
              }
            });
            ```
        *   **自身不包含任何业务逻辑**，只是一个“调度员”。

*   **`errorHandler.ts`**
    *   **职责**: **全局、统一的错误处理中心**。
    *   **实现要点**:
        *   导出一个 `handle(error)` 函数。
        *   内部使用 `instanceof` 来判断错误类型（`StockUnavailableError`, `AuthenticationError`, `ValidationError` 等）。
        *   根据不同的错误类型，返回给前端一个**结构化、可预测**的错误对象，如 `{ success: false, error: { code: 'STOCK_ERROR', message: '库存不足' } }`。

*   **`logger.ts`**
    *   **职责**: 提供应用级的日志记录服务。
    *   **技术选型**: 使用 `electron-log`。
    *   **实现要点**:
        *   配置日志级别（info, warn, error）、输出格式和存储位置。
        *   在关键路径（如用户登录、关键服务调用、错误处理）中插入日志记录，方便调试和问题追溯。

#### **`src/main/database/` - 数据库连接**

*   **`index.ts`**
    *   **职责**: 初始化并导出数据库连接实例（SQLite 和/或 LanceDB）。
    *   **实现要点**:
        *   负责执行 `CREATE TABLE IF NOT EXISTS ...` 来初始化所有数据表结构。
        *   导出一个或多个可供所有 Repository 使用的数据库实例。

---

### **Part 2: 预加载脚本 (Preload Script) - 安全的API桥梁**

*   **`src/preload/index.ts`**
    *   **职责**: **以类型安全的方式，将主进程的功能暴露给渲染进程**。这是Electron推荐的最佳安全实践。
    *   **实现要点**:
        *   使用 `contextBridge.exposeInMainWorld('api', { ... })`。
        *   暴露的方法与 `ipcHandlers.ts` 中的频道一一对应，形成一个清晰的API契约。
        *   **示例**: `borrowBook: (readerId, bookId) => ipcRenderer.invoke('borrow-book', readerId, bookId)`。

---

### **Part 3: 渲染进程 (Renderer Process) - UI与用户交互**

前端也应遵循分层思想，以保持代码的整洁。

*   **`src/renderer/src/api/` - 前端数据获取层**
    *   **职责**: **封装所有对 `window.api` 的调用**。Vue组件不应直接访问全局的 `window.api`。
    *   **实现要点**:
        *   按领域创建文件，如 `api/borrowing.ts`。
        *   **示例 (`borrowing.ts`)**: `export const borrowBookApi = (readerId, bookId) => window.api.borrowBook(readerId, bookId);`
        *   **好处**: 如果未来IPC频道名或参数变更，只需修改API层，无需触碰任何Vue组件。

*   **`src/renderer/src/views/` - 视图组件**
    *   **职责**: 负责界面的展示和用户事件的响应。
    *   **实现要点**:
        *   通过 `import { borrowBookApi } from '@/api/borrowing';` 导入并调用API。
        *   只处理UI逻辑（如加载状态 `isLoading`、显示/隐藏对话框）。
        *   复杂的、跨组件的状态会交给 Pinia store 管理。

*   **`src/renderer/src/store/` - 全局状态管理**
    *   **技术选型**: Pinia。
    *   **职责**: 管理需要全局共享的状态，如当前登录用户信息、权限、全局通知等。
    *   **示例 (`user.ts`)**: 存储 `user` 对象和 `token`，提供 `isAdmin` 等 getter。

---

### **Part 4: 项目工具与质量保障**

这些部分确保了项目的健壮性和开发效率。

*   **`tests/` - 自动化测试**
    *   **`tests/services/borrowing.service.spec.ts` (单元测试)**
        *   **技术选型**: `Vitest`。
        *   **核心思想**: **对 `BorrowingService` 进行隔离测试**。
        *   **实现要点**:
            *   使用 `vi.mock()` **模拟**所有被 `BorrowingService` 依赖的 Repository。
            *   例如，让 `mockBookRepository.findById` 返回一本书，让 `mockInventoryRepository.getAvailableCount` 返回0。
            *   断言（`expect`）在这种情况下调用 `borrowingService.borrowBook()` 会抛出 `StockUnavailableError`。

    *   **`tests/e2e/` (端到端测试)**
        *   **技术选型**: `Playwright`。
        *   **核心思想**: 模拟真实用户从头到尾的操作，验证整个应用流的正确性。

*   **`.github/workflows/` - 持续集成/持续部署 (CI/CD)**
    *   **职责**: 自动化代码检查、测试和打包流程。
    *   **实现要点**:
        *   配置一个工作流，在每次 `push` 或 `pull request` 时自动执行：
            1.  `npm install`
            2.  `npm run lint` (代码风格检查)
            3.  `npm run test:unit` (运行所有单元测试)
            4.  `npm run build` (确保应用可以成功打包)

---

### **一个完整功能的实现流程示例：添加“图书续借”功能**

1.  **数据库**: 在 `borrowing` 表中可能需要添加 `renewal_count` 字段。
2.  **Repository层 (`borrowing.repository.ts`):** 新增 `incrementRenewalCount(recordId)` 方法，用于执行 `UPDATE ...` SQL语句。
3.  **Service层 (`borrowing.service.ts`):**
    *   创建新的 `renewBook(recordId)` 方法。
    *   **内部业务逻辑**:
        *   调用 `borrowingRepository.findById(recordId)` 找到借阅记录。
        *   检查续借次数是否已达上限（业务规则）。
        *   检查是否有其他读者预定了这本书（业务规则）。
        *   如果通过，调用 `borrowingRepository.incrementRenewalCount()` 和 `update()` 来更新还书日期。
4.  **Handler层 (`ipcHandlers.ts`):** 添加 `ipcMain.handle('renew-book', ...)`，内部用 `try...catch` 包裹对 `borrowingService.renewBook()` 的调用。
5.  **Preload层 (`preload/index.ts`):** 在 `api` 对象中暴露 `renewBook: (recordId) => ipcRenderer.invoke('renew-book', recordId)`。
6.  **前端API层 (`renderer/src/api/borrowing.ts`):** 添加 `export const renewBookApi = ...`。
7.  **前端视图层 (`MyBorrows.vue`):** 添加一个“续借”按钮，`@click` 事件调用 `renewBookApi`，并根据返回结果更新UI（如显示成功消息或错误提示）。
8.  **测试 (`tests/`):** 为 `renewBook` 服务编写新的单元测试，覆盖成功和各种失败的场景。

### 

让我们看看文件树中专门为 AI 设计的部分，以及它们如何与其他领域互动。

#### **文件树中的 AI 核心集成点**

```
electron-smart-library/
├── src/
│   ├── main/
│   │   ├── domains/
│   │   │   ├── book/
│   │   │   │   ├── book.service.ts   # 👈 会与 AI Service 互动
│   │   │   │   └── book.repository.ts
│   │   │   ├── ai/                   # 👈 AI领域：所有智能功能的核心
│   │   │   │   ├── ai.service.ts     # 智能业务编排 (RAG, 聊天逻辑)
│   │   │   │   ├── embedding.service.ts # 专门负责生成文本向量
│   │   │   │   └── vector.repository.ts # 向量数据库的唯一接口
│   │   │   └── ...
│   │   ├── lib/
│   │   │   ├── ipcHandlers.ts      # 👈 新增 AI 相关的 IPC 接口
│   │   └── ...
│   │
│   └── renderer/
│       ├── src/
│       │   ├── api/
│       │   │   └── ai.ts             # 👈 前端调用AI功能的API封装
│       │   ├── components/
│       │   │   └── MarkdownRenderer.vue # 👈 用于渲染AI返回的Markdown
│       │   ├── views/
│       │   │   └── AgentView.vue     # 👈 AI助手的聊天界面
│       │   └── ...
│
└── ...
```

---

### **两大 AI 功能的实现流程 (端到端)**

#### **功能一: AI 语义搜索 (向量搜索)**

**目标**: 用户输入“关于星际旅行和时间悖论的科幻小说”，系统能找到《三体》或《银河系漫游指南》，即使这些书中并没有完全匹配的关键词。

##### **第1步: 数据嵌入 (数据准备阶段)**

这个过程在图书被**创建或更新**时自动触发，是实现搜索的基础。

1.  **触发点**: 管理员通过 `BooksView.vue` 添加或编辑一本书。请求通过 IPC 到达 `ipcHandlers.ts`，最终调用 `book.service.ts` 的 `createBook()` 或 `updateBook()` 方法。
2.  **领域协作**: 在 `book.service.ts` 成功将图书信息存入 SQL 数据库后，它会**立即调用 `ai.service.ts`** 的一个方法，比如 `createBookEmbedding(bookId, bookDescription)`。
3.  **向量生成**: `ai.service.ts` 接收到任务后，将书籍的描述、标题、标签等文本信息，传递给 `embedding.service.ts`。
4.  **外部 API 调用**: `embedding.service.ts` 是唯一与外部 Embedding 模型（如 OpenAI `text-embedding-3-small`）交互的模块。它负责调用 API，将文本转换为一串数字（向量），然后返回给 `ai.service.ts`。
5.  **存入向量库**: `ai.service.ts` 拿到向量后，调用 `vector.repository.ts` 的 `save(bookId, vector)` 方法，将书籍的 ID 和其对应的向量存入 **LanceDB** 或 **ChromaDB**。

##### **第2步: 用户查询 (实时搜索阶段)**

1.  **触发点**: 用户在前端的搜索框中输入查询文本，并选择“语义搜索”。请求通过 `ai.ts` API 封装，调用 `ipcMain.handle('ai-semantic-search', ...)`。
2.  **查询向量化**: `ipcHandlers.ts` 调用 `ai.service.ts` 的 `findSimilarBooks(queryText)`。`ai.service.ts` 首先会调用 `embedding.service.ts` 将用户的**查询文本也转换成一个向量**。
3.  **向量匹配**: `ai.service.ts` 拿着这个查询向量，调用 `vector.repository.ts` 的 `search(queryVector, { topK: 5 })` 方法。
4.  **获取结果**: `vector.repository.ts` 在向量数据库中执行相似度搜索，返回最相似的 `5` 个书籍的 ID。
5.  **数据整合**: `ai.service.ts` 拿到书籍 ID 列表后，会调用 `book.repository.ts` 的 `findByIds([...])` 方法，从 SQL 数据库中获取这些书籍的完整信息（标题、作者、封面等）。
6.  **返回前端**: 最终，完整的书籍信息列表被返回给前端进行展示。

#### **功能二: AI 助手 (智能问答)**

**目标**: 用户可以在 `AgentView.vue` 中提问：“我喜欢看《权力的游戏》，还能推荐一些类似的史诗奇幻吗？请说明理由。” AI 助手能够结合馆藏图书进行个性化推荐。

这个功能使用了目前最先进的 **RAG (Retrieval-Augmented Generation，检索增强生成)** 技术。

##### **实现流程:**

1.  **触发点**: 用户在 `AgentView.vue` 的聊天框中输入问题，点击发送。请求通过 `ipcMain.handle('ai-ask-assistant', ...)` 到达后端。
2.  **意图理解与检索 (Retrieval)**: `ipcHandlers.ts` 调用 `ai.service.ts` 的 `getChatResponse(question, chatHistory)` 方法。
    *   `ai.service.ts` **首先执行一次内部的语义搜索**！它会调用 `findSimilarBooks(question)` 来从向量数据库中找出与用户问题最相关的几本书籍。这就是“检索”步骤。

3.  **提示词增强 (Augmented)**: `ai.service.ts` 现在开始构建一个复杂的、信息量巨大的**提示词 (Prompt)**。这个 Prompt 类似这样：
    ```
    你是一个专业的图书管理员助手。请根据以下背景信息来回答用户的问题。
    
    [背景信息 - 我馆相关藏书]:
    - 书名: 《风之名》, 简介: 一个关于传奇人物克沃特的成长故事，魔法系统独特...
    - 书名: 《王者之路》, 简介: 布兰登·桑德森的宏大史诗开篇...
    
    [用户聊天历史]:
    - 用户: ...
    - 助手: ...
    
    [用户当前问题]:
    "我喜欢看《权力的游戏》，还能推荐一些类似的史诗奇幻吗？请说明理由。"
    
    请根据以上信息，为用户提供2-3本图书推荐，并以Markdown格式解释推荐理由。
    ```

4.  **生成回答 (Generation)**: `ai.service.ts` 将这个精心构建的 Prompt 发送给大语言模型 (LLM, 如 GPT-4 或 Gemini)。
5.  **返回并渲染**: LLM 返回一个包含详细理由的、Markdown 格式的回答。`ai.service.ts` 将其返回给前端。`AgentView.vue` 接收到这个 Markdown 字符串后，使用 `MarkdownRenderer.vue` 组件将其优雅地渲染成富文本，呈现给用户。

